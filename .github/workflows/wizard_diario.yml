# wizard_brain.py
from __future__ import annotations
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans


# ============================================================
#   DETECÇÃO DE QUENTES E FRIAS
# ============================================================

def detectar_quentes_frias(df: pd.DataFrame, janela: int = 30):
    ultimos = df.tail(janela)

    freq = {}
    for d in range(1, 26):
        freq[d] = (ultimos == d).sum().sum()

    media = np.mean(list(freq.values()))

    quentes = [d for d, f in freq.items() if f > media]
    frias   = [d for d, f in freq.items() if f < media]

    return quentes, frias, freq


# ============================================================
#   CLUSTERIZAÇÃO DOS ÚLTIMOS CONCURSOS
# ============================================================

def clusterizar_concursos(df: pd.DataFrame, k: int = 3):
    matriz = []

    for _, row in df.iterrows():
        dezenas = [row[f"D{i}"] for i in range(1, 16)]
        vetor_bin = [1 if d in dezenas else 0 for d in range(1, 26)]
        matriz.append(vetor_bin)

    matriz = np.array(matriz)

    modelo = KMeans(n_clusters=k, n_init=10)
    modelo.fit(matriz)

    return modelo, matriz


# ============================================================
#   SCORE DE PROBABILIDADE COMBINATÓRIA
# ============================================================

def score_probabilidade(dezenas: list[int]):
    pares = sum(1 for d in dezenas if d % 2 == 0)
    impares = 15 - pares

    # Probabilidades históricas mais comuns:
    # 7-8 ou 8-7 pares/ímpares
    if pares in (7, 8):
        return 1.0
    if pares in (6, 9):
        return 0.5

    return 0.1  # fugiu do padrão típico


# ============================================================
#   DISTÂNCIA ENTRE DOIS JOGOS
# ============================================================

def distancia_jogos(j1: list[int], j2: list[int]) -> float:
    v1 = np.array([1 if i in j1 else 0 for i in range(1, 26)])
    v2 = np.array([1 if i in j2 else 0 for i in range(1, 26)])
    return np.linalg.norm(v1 - v2)


# ============================================================
#   SCORE FINAL INTELIGENTE
# ============================================================

def calcular_score_inteligente(
    dezenas: list[int],
    ultimos_tuplas: set[tuple[int, ...]],
    cobertura_contagem: dict[int, int],
    quentes: list[int],
    frias: list[int],
    freq: dict[int, int],
    modelo_cluster: KMeans,
    config,
    jogos_ja_escolhidos: list[list[int]]
):
    dezenas_set = set(dezenas)

    # -------------------------
    # Score de cobertura
    # -------------------------
    score_cobertura = sum(1 / (1 + cobertura_contagem[d]) for d in dezenas)

    # -------------------------
    # Score quente/frio
    # -------------------------
    score_quente = sum(freq[d] for d in dezenas if d in quentes)
    score_frio   = sum(1 for d in dezenas if d in frias)

    # -------------------------
    # Similaridade com clusters recentes
    # -------------------------
    vetor = np.array([1 if i in dezenas else 0 for i in range(1, 26)]).reshape(1, -1)
    cluster_jogo = modelo_cluster.predict(vetor)[0]

    # Se repetir muitos concursos do mesmo cluster → penaliza
    repete_cluster = sum(
        1 for ult in ultimos_tuplas
        if modelo_cluster.predict([[1 if i in ult else 0 for i in range(1, 26)]])[0] == cluster_jogo
    )

    score_cluster = max(0, 5 - repete_cluster)

    # -------------------------
    # Probabilidade combinatória
    # -------------------------
    score_prob = score_probabilidade(dezenas)

    # -------------------------
    # Distância para evitar jogos parecidos entre si
    # -------------------------
    if jogos_ja_escolhidos:
        distancias = [
            distancia_jogos(dezenas, j) for j in jogos_ja_escolhidos
        ]
        score_distancia = min(distancias)  # quanto maior, melhor
    else:
        score_distancia = 1.0

    # -------------------------
    # Penalidade repetição últimos concursos
    # -------------------------
    max_overlap = max(len(dezenas_set.intersection(ult)) for ult in ultimos_tuplas)

    if config.modo == "conservador":
        penalidade = max(0, max_overlap - 9)
    else:
        penalidade = max(0, max_overlap - 11)

    # -------------------------
    # SCORE FINAL
    # -------------------------
    score_final = (
        2.0 * score_cobertura +
        1.5 * score_quente +
        0.5 * score_frio +
        1.2 * score_cluster +
        1.3 * score_prob +
        1.1 * score_distancia -
        1.8 * penalidade
    )

    return score_final